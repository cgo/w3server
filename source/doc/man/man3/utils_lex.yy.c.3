.TH "lex.yy.c" 3 "6 Jul 2006" "Version 1.0" "w3server" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lex.yy.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdio.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fByy_buffer_state\fP"
.br
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBFLEX_SCANNER\fP"
.br
.ti -1c
.RI "#define \fBYY_FLEX_MAJOR_VERSION\fP   2"
.br
.ti -1c
.RI "#define \fBYY_FLEX_MINOR_VERSION\fP   5"
.br
.ti -1c
.RI "#define \fByyconst\fP"
.br
.ti -1c
.RI "#define \fBYY_PROTO\fP(proto)   ()"
.br
.ti -1c
.RI "#define \fBYY_NULL\fP   0"
.br
.ti -1c
.RI "#define \fBYY_SC_TO_UI\fP(c)   ((unsigned int) (unsigned char) c)"
.br
.ti -1c
.RI "#define \fBBEGIN\fP   yy_start = 1 + 2 *"
.br
.ti -1c
.RI "#define \fBYY_START\fP   ((yy_start - 1) / 2)"
.br
.ti -1c
.RI "#define \fBYYSTATE\fP   YY_START"
.br
.ti -1c
.RI "#define \fBYY_STATE_EOF\fP(state)   (YY_END_OF_BUFFER + state + 1)"
.br
.ti -1c
.RI "#define \fBYY_NEW_FILE\fP   yyrestart( \fByyin\fP )"
.br
.ti -1c
.RI "#define \fBYY_END_OF_BUFFER_CHAR\fP   0"
.br
.ti -1c
.RI "#define \fBYY_BUF_SIZE\fP   16384"
.br
.ti -1c
.RI "#define \fBEOB_ACT_CONTINUE_SCAN\fP   0"
.br
.ti -1c
.RI "#define \fBEOB_ACT_END_OF_FILE\fP   1"
.br
.ti -1c
.RI "#define \fBEOB_ACT_LAST_MATCH\fP   2"
.br
.ti -1c
.RI "#define \fByyless\fP(n)"
.br
.ti -1c
.RI "#define \fBunput\fP(c)   yyunput( c, yytext_ptr )"
.br
.ti -1c
.RI "#define \fBYY_BUFFER_NEW\fP   0"
.br
.ti -1c
.RI "#define \fBYY_BUFFER_NORMAL\fP   1"
.br
.ti -1c
.RI "#define \fBYY_BUFFER_EOF_PENDING\fP   2"
.br
.ti -1c
.RI "#define \fBYY_CURRENT_BUFFER\fP   yy_current_buffer"
.br
.ti -1c
.RI "#define \fBYY_FLUSH_BUFFER\fP   yy_flush_buffer( yy_current_buffer )"
.br
.ti -1c
.RI "#define \fByy_new_buffer\fP   yy_create_buffer"
.br
.ti -1c
.RI "#define \fByy_set_interactive\fP(is_interactive)"
.br
.ti -1c
.RI "#define \fByy_set_bol\fP(at_bol)"
.br
.ti -1c
.RI "#define \fBYY_AT_BOL\fP()   (yy_current_buffer->yy_at_bol)"
.br
.ti -1c
.RI "#define \fByytext_ptr\fP   \fByytext\fP"
.br
.ti -1c
.RI "#define \fBYY_DO_BEFORE_ACTION\fP"
.br
.ti -1c
.RI "#define \fBYY_NUM_RULES\fP   7"
.br
.ti -1c
.RI "#define \fBYY_END_OF_BUFFER\fP   8"
.br
.ti -1c
.RI "#define \fBREJECT\fP   reject_used_but_not_detected"
.br
.ti -1c
.RI "#define \fByymore\fP()   yymore_used_but_not_detected"
.br
.ti -1c
.RI "#define \fBYY_MORE_ADJ\fP   0"
.br
.ti -1c
.RI "#define \fBYY_RESTORE_YY_MORE_OFFSET\fP"
.br
.ti -1c
.RI "#define \fBINITIAL\fP   0"
.br
.ti -1c
.RI "#define \fBIMAGENAME\fP   1"
.br
.ti -1c
.RI "#define \fBIMAGEFILENAME\fP   2"
.br
.ti -1c
.RI "#define \fBIMAGETAIL\fP   3"
.br
.ti -1c
.RI "#define \fBIMAGEREMOTE\fP   4"
.br
.ti -1c
.RI "#define \fBYY_NO_PUSH_STATE\fP   1"
.br
.ti -1c
.RI "#define \fBYY_NO_POP_STATE\fP   1"
.br
.ti -1c
.RI "#define \fBYY_NO_TOP_STATE\fP   1"
.br
.ti -1c
.RI "#define \fBYY_READ_BUF_SIZE\fP   8192"
.br
.ti -1c
.RI "#define \fBECHO\fP   (void) fwrite( \fByytext\fP, \fByyleng\fP, 1, \fByyout\fP )"
.br
.ti -1c
.RI "#define \fBYY_INPUT\fP(buf, result, max_size)"
.br
.ti -1c
.RI "#define \fByyterminate\fP()   return YY_NULL"
.br
.ti -1c
.RI "#define \fBYY_START_STACK_INCR\fP   25"
.br
.ti -1c
.RI "#define \fBYY_FATAL_ERROR\fP(msg)   yy_fatal_error( msg )"
.br
.ti -1c
.RI "#define \fBYY_DECL\fP   int yylex YY_PROTO(( void ))"
.br
.ti -1c
.RI "#define \fBYY_BREAK\fP   break;"
.br
.ti -1c
.RI "#define \fBYY_RULE_SETUP\fP   YY_USER_ACTION"
.br
.ti -1c
.RI "#define \fBYY_EXIT_FAILURE\fP   2"
.br
.ti -1c
.RI "#define \fByyless\fP(n)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fByy_buffer_state\fP * \fBYY_BUFFER_STATE\fP"
.br
.ti -1c
.RI "typedef unsigned int \fByy_size_t\fP"
.br
.ti -1c
.RI "typedef unsigned char \fBYY_CHAR\fP"
.br
.ti -1c
.RI "typedef int \fByy_state_type\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void yyrestart \fBYY_PROTO\fP ((FILE *input_file))"
.br
.ti -1c
.RI "void yy_switch_to_buffer \fBYY_PROTO\fP ((\fBYY_BUFFER_STATE\fP new_buffer))"
.br
.ti -1c
.RI "void yy_load_buffer_state \fBYY_PROTO\fP ((void))"
.br
.ti -1c
.RI "\fBYY_BUFFER_STATE\fP yy_create_buffer \fBYY_PROTO\fP ((FILE *file, int \fBsize\fP))"
.br
.ti -1c
.RI "void yy_delete_buffer \fBYY_PROTO\fP ((\fBYY_BUFFER_STATE\fP b))"
.br
.ti -1c
.RI "void yy_init_buffer \fBYY_PROTO\fP ((\fBYY_BUFFER_STATE\fP b, FILE *file))"
.br
.ti -1c
.RI "\fBYY_BUFFER_STATE\fP yy_scan_buffer \fBYY_PROTO\fP ((char *base, \fByy_size_t\fP \fBsize\fP))"
.br
.ti -1c
.RI "\fBYY_BUFFER_STATE\fP yy_scan_string \fBYY_PROTO\fP ((yyconst char *yy_str))"
.br
.ti -1c
.RI "\fBYY_BUFFER_STATE\fP yy_scan_bytes \fBYY_PROTO\fP ((yyconst char *bytes, int len))"
.br
.ti -1c
.RI "void \fByy_init_buffer\fP (\fBYY_BUFFER_STATE\fP b, FILE *file)"
.br
.ti -1c
.RI "void \fByy_flush_buffer\fP (\fBYY_BUFFER_STATE\fP b)"
.br
.ti -1c
.RI "\fBYY_BUFFER_STATE\fP \fByy_scan_buffer\fP (char *base, \fByy_size_t\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBYY_BUFFER_STATE\fP \fByy_scan_string\fP (yyconst char *yy_str)"
.br
.ti -1c
.RI "\fBYY_BUFFER_STATE\fP \fByy_scan_bytes\fP (yyconst char *bytes, int len)"
.br
.ti -1c
.RI "\fBmain\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fByyleng\fP"
.br
.ti -1c
.RI "FILE * \fByyin\fP"
.br
.ti -1c
.RI "FILE * \fByyout\fP"
.br
.ti -1c
.RI "int \fByyleng\fP"
.br
.ti -1c
.RI "FILE * \fByyin\fP = (FILE *) 0"
.br
.ti -1c
.RI "FILE * \fByyout\fP = (FILE *) 0"
.br
.ti -1c
.RI "char * \fByytext\fP"
.br
.ti -1c
.RI "char * \fByytext\fP"
.br
.ti -1c
.RI "register char * \fByy_bp\fP"
.br
.ti -1c
.RI "int \fBsize\fP"
.br
.in -1c
.SH "Define Documentation"
.PP 
.SS "#define BEGIN   yy_start = 1 + 2 *"
.PP
.SS "#define ECHO   (void) fwrite( \fByytext\fP, \fByyleng\fP, 1, \fByyout\fP )"
.PP
.SS "#define EOB_ACT_CONTINUE_SCAN   0"
.PP
.SS "#define EOB_ACT_END_OF_FILE   1"
.PP
.SS "#define EOB_ACT_LAST_MATCH   2"
.PP
.SS "#define FLEX_SCANNER"
.PP
.SS "#define IMAGEFILENAME   2"
.PP
.SS "#define IMAGENAME   1"
.PP
.SS "#define IMAGEREMOTE   4"
.PP
.SS "#define IMAGETAIL   3"
.PP
.SS "#define INITIAL   0"
.PP
.SS "#define REJECT   reject_used_but_not_detected"
.PP
.SS "#define unput(c)   yyunput( c, yytext_ptr )"
.PP
.SS "#define YY_AT_BOL()   (yy_current_buffer->yy_at_bol)"
.PP
.SS "#define YY_BREAK   break;"
.PP
.SS "#define YY_BUF_SIZE   16384"
.PP
.SS "#define YY_BUFFER_EOF_PENDING   2"
.PP
.SS "#define YY_BUFFER_NEW   0"
.PP
.SS "#define YY_BUFFER_NORMAL   1"
.PP
.SS "#define YY_CURRENT_BUFFER   yy_current_buffer"
.PP
.SS "#define YY_DECL   int yylex YY_PROTO(( void ))"
.PP
.SS "#define YY_DO_BEFORE_ACTION"
.PP
\fBValue:\fP
.PP
.nf
yytext_ptr = yy_bp; \
        yyleng = (int) (yy_cp - yy_bp); \
        yy_hold_char = *yy_cp; \
        *yy_cp = '\0'; \
        yy_c_buf_p = yy_cp;
.fi
.SS "#define YY_END_OF_BUFFER   8"
.PP
.SS "#define YY_END_OF_BUFFER_CHAR   0"
.PP
.SS "#define YY_EXIT_FAILURE   2"
.PP
.SS "#define YY_FATAL_ERROR(msg)   yy_fatal_error( msg )"
.PP
.SS "#define YY_FLEX_MAJOR_VERSION   2"
.PP
.SS "#define YY_FLEX_MINOR_VERSION   5"
.PP
.SS "#define YY_FLUSH_BUFFER   yy_flush_buffer( yy_current_buffer )"
.PP
.SS "#define YY_INPUT(buf, result, max_size)"
.PP
\fBValue:\fP
.PP
.nf
if ( yy_current_buffer->yy_is_interactive ) \
                { \
                int c = '*', n; \
                for ( n = 0; n < max_size && \
                             (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
                        buf[n] = (char) c; \
                if ( c == '\n' ) \
                        buf[n++] = (char) c; \
                if ( c == EOF && ferror( yyin ) ) \
                        YY_FATAL_ERROR( 'input in flex scanner failed' ); \
                result = n; \
                } \
        else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
                  && ferror( yyin ) ) \
                YY_FATAL_ERROR( 'input in flex scanner failed' );
.fi
.SS "#define YY_MORE_ADJ   0"
.PP
.SS "#define yy_new_buffer   yy_create_buffer"
.PP
.SS "#define YY_NEW_FILE   yyrestart( \fByyin\fP )"
.PP
.SS "#define YY_NO_POP_STATE   1"
.PP
.SS "#define YY_NO_PUSH_STATE   1"
.PP
.SS "#define YY_NO_TOP_STATE   1"
.PP
.SS "#define YY_NULL   0"
.PP
.SS "#define YY_NUM_RULES   7"
.PP
.SS "#define YY_PROTO(proto)   ()"
.PP
.SS "#define YY_READ_BUF_SIZE   8192"
.PP
.SS "#define YY_RESTORE_YY_MORE_OFFSET"
.PP
.SS "#define YY_RULE_SETUP   YY_USER_ACTION"
.PP
.SS "#define YY_SC_TO_UI(c)   ((unsigned int) (unsigned char) c)"
.PP
.SS "#define yy_set_bol(at_bol)"
.PP
\fBValue:\fP
.PP
.nf
{ \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
        yy_current_buffer->yy_at_bol = at_bol; \
        }
.fi
.SS "#define yy_set_interactive(is_interactive)"
.PP
\fBValue:\fP
.PP
.nf
{ \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
        yy_current_buffer->yy_is_interactive = is_interactive; \
        }
.fi
.SS "#define YY_START   ((yy_start - 1) / 2)"
.PP
.SS "#define YY_START_STACK_INCR   25"
.PP
.SS "#define YY_STATE_EOF(state)   (YY_END_OF_BUFFER + state + 1)"
.PP
.SS "#define yyconst"
.PP
.SS "#define yyless(n)"
.PP
\fBValue:\fP
.PP
.nf
do \
                { \
                /* Undo effects of setting up yytext. */ \
                yytext[yyleng] = yy_hold_char; \
                yy_c_buf_p = yytext + n; \
                yy_hold_char = *yy_c_buf_p; \
                *yy_c_buf_p = '\0'; \
                yyleng = n; \
                } \
        while ( 0 )
.fi
.SS "#define yyless(n)"
.PP
\fBValue:\fP
.PP
.nf
do \
                { \
                /* Undo effects of setting up yytext. */ \
                *yy_cp = yy_hold_char; \
                YY_RESTORE_YY_MORE_OFFSET \
                yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
                YY_DO_BEFORE_ACTION; /* set up yytext again */ \
                } \
        while ( 0 )
.fi
.SS "#define yymore()   yymore_used_but_not_detected"
.PP
.SS "#define YYSTATE   YY_START"
.PP
.SS "#define yyterminate()   return YY_NULL"
.PP
.SS "#define yytext_ptr   \fByytext\fP"
.PP
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fByy_buffer_state\fP* \fBYY_BUFFER_STATE\fP"
.PP
.SS "typedef unsigned char \fBYY_CHAR\fP"
.PP
.SS "typedef unsigned int \fByy_size_t\fP"
.PP
.SS "typedef int \fByy_state_type\fP"
.PP
.SH "Function Documentation"
.PP 
.SS "main ()"
.PP
.SS "void yy_flush_buffer (\fBYY_BUFFER_STATE\fP b)"
.PP
.SS "void yy_init_buffer (\fBYY_BUFFER_STATE\fP b, FILE * file)"
.PP
.SS "\fBYY_BUFFER_STATE\fP yy_scan_bytes YY_PROTO ((yyconst char *bytes, int len))"
.PP
.SS "\fBYY_BUFFER_STATE\fP yy_scan_string YY_PROTO ((yyconst char *yy_str))"
.PP
.SS "\fBYY_BUFFER_STATE\fP yy_scan_buffer YY_PROTO ((char *base, \fByy_size_t\fP \fBsize\fP))"
.PP
.SS "void yy_init_buffer YY_PROTO ((\fBYY_BUFFER_STATE\fP b, FILE *file))"
.PP
.SS "void yy_delete_buffer YY_PROTO ((\fBYY_BUFFER_STATE\fP b))"
.PP
.SS "\fBYY_BUFFER_STATE\fP yy_create_buffer YY_PROTO ((FILE *file, int \fBsize\fP))"
.PP
.SS "void yy_load_buffer_state YY_PROTO ((void))"
.PP
.SS "void yy_switch_to_buffer YY_PROTO ((\fBYY_BUFFER_STATE\fP new_buffer))"
.PP
.SS "void yyrestart YY_PROTO ((FILE *input_file))"
.PP
.SS "\fBYY_BUFFER_STATE\fP yy_scan_buffer (char * base, \fByy_size_t\fP size)"
.PP
.SS "\fBYY_BUFFER_STATE\fP yy_scan_bytes (yyconst char * bytes, int len)"
.PP
.SS "\fBYY_BUFFER_STATE\fP yy_scan_string (yyconst char * yy_str)"
.PP
.SH "Variable Documentation"
.PP 
.SS "int \fBsize\fP"
.PP
.SS "register char* \fByy_bp\fP"
.PP
.SS "FILE* \fByyin\fP = (FILE *) 0"
.PP
.SS "FILE* \fByyin\fP"
.PP
.SS "int \fByyleng\fP"
.PP
.SS "int \fByyleng\fP"
.PP
.SS "FILE * \fByyout\fP = (FILE *) 0"
.PP
.SS "FILE * \fByyout\fP"
.PP
.SS "char* \fByytext\fP"
.PP
.SS "char* \fByytext\fP"
.PP
.SH "Author"
.PP 
Generated automatically by Doxygen for w3server from the source code.
